/*
	This file is part of Retro Graphics Toolkit

	Retro Graphics Toolkit is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or any later version.

	Retro Graphics Toolkit is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Retro Graphics Toolkit. If not, see <http://www.gnu.org/licenses/>.
	Copyright Sega16 (or whatever you wish to call me) (2012-2016)
*/
/**
 *
 * MACHINE GENERATED FILE. DO NOT EDIT.
 *
 * Bindings for library undo
 *
 * This file has been generated by dub 2.2.3.
 */
#include "dub/dub.h"
#include "undo.h"


extern "C" {
}

/** void pushTile(unsigned int id, tileTypeMask_t type)
 * inc/undo.h:9
 */
static int undo_pushTile(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 2);
		pushTile(id, type);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTile: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTile: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilenew(unsigned int id)
 * inc/undo.h:10
 */
static int undo_pushTilenew(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		pushTilenew(id);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilenew: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilenew: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilePixel(unsigned int id, unsigned int x, unsigned int y, tileTypeMask_t type)
 * inc/undo.h:11
 */
static int undo_pushTilePixel(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		unsigned int x = dub::checkinteger(L, 2);
		unsigned int y = dub::checkinteger(L, 3);
		tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 4);
		pushTilePixel(id, x, y, type);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilePixel: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilePixel: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTileGroupPrepare(tileTypeMask_t type)
 * inc/undo.h:12
 */
static int undo_pushTileGroupPrepare(lua_State *L) {
	try {
		tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 1);
		pushTileGroupPrepare(type);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTileGroupPrepare: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTileGroupPrepare: Unknown exception");
	}

	return lua_error(L);
}

/** void addTileGroup(unsigned int tile, int forceid=-1)
 * inc/undo.h:13
 */
static int undo_addTileGroup(lua_State *L) {
	try {
		int top__ = lua_gettop(L);

		if (top__ >= 2) {
			unsigned int tile = dub::checkinteger(L, 1);
			int forceid = dub::checkinteger(L, 2);
			addTileGroup(tile, forceid);
			return 0;
		} else {
			unsigned int tile = dub::checkinteger(L, 1);
			addTileGroup(tile);
			return 0;
		}
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.addTileGroup: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.addTileGroup: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTileappendGroupPrepare(void)
 * inc/undo.h:14
 */
static int undo_pushTileappendGroupPrepare(lua_State *L) {
	try {
		pushTileappendGroupPrepare();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTileappendGroupPrepare: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTileappendGroupPrepare: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilesAll(tileTypeMask_t type)
 * inc/undo.h:15
 */
static int undo_pushTilesAll(lua_State *L) {
	try {
		tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 1);
		pushTilesAll(type);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilesAll: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilesAll: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTileAppend(void)
 * inc/undo.h:16
 */
static int undo_pushTileAppend(lua_State *L) {
	try {
		pushTileAppend();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTileAppend: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTileAppend: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilemapEdit(unsigned int x, unsigned int y)
 * inc/undo.h:17
 */
static int undo_pushTilemapEdit(lua_State *L) {
	try {
		unsigned int x = dub::checkinteger(L, 1);
		unsigned int y = dub::checkinteger(L, 2);
		pushTilemapEdit(x, y);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilemapEdit: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilemapEdit: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilemapResize(unsigned int wnew, unsigned int hnew)
 * inc/undo.h:18
 */
static int undo_pushTilemapResize(lua_State *L) {
	try {
		unsigned int wnew = dub::checkinteger(L, 1);
		unsigned int hnew = dub::checkinteger(L, 2);
		pushTilemapResize(wnew, hnew);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilemapResize: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilemapResize: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilemapBlocksAmt(unsigned int amtnew)
 * inc/undo.h:19
 */
static int undo_pushTilemapBlocksAmt(lua_State *L) {
	try {
		unsigned int amtnew = dub::checkinteger(L, 1);
		pushTilemapBlocksAmt(amtnew);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilemapBlocksAmt: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilemapBlocksAmt: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilemapAll(bool attrOnly)
 * inc/undo.h:20
 */
static int undo_pushTilemapAll(lua_State *L) {
	try {
		bool attrOnly = dub::checkboolean(L, 1);
		pushTilemapAll(attrOnly);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilemapAll: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilemapAll: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilemapPlaneDelete(unsigned int plane)
 * inc/undo.h:21
 */
static int undo_pushTilemapPlaneDelete(lua_State *L) {
	try {
		unsigned int plane = dub::checkinteger(L, 1);
		pushTilemapPlaneDelete(plane);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilemapPlaneDelete: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilemapPlaneDelete: Unknown exception");
	}

	return lua_error(L);
}

/** void pushTilemapPlaneAdd(unsigned int plane)
 * inc/undo.h:22
 */
static int undo_pushTilemapPlaneAdd(lua_State *L) {
	try {
		unsigned int plane = dub::checkinteger(L, 1);
		pushTilemapPlaneAdd(plane);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushTilemapPlaneAdd: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushTilemapPlaneAdd: Unknown exception");
	}

	return lua_error(L);
}

/** void pushExtAttrs(unsigned int plane)
 * inc/undo.h:23
 */
static int undo_pushExtAttrs(lua_State *L) {
	try {
		unsigned int plane = dub::checkinteger(L, 1);
		pushExtAttrs(plane);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushExtAttrs: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushExtAttrs: Unknown exception");
	}

	return lua_error(L);
}

/** void pushPaletteEntry(unsigned int id)
 * inc/undo.h:24
 */
static int undo_pushPaletteEntry(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		pushPaletteEntry(id);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushPaletteEntry: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushPaletteEntry: Unknown exception");
	}

	return lua_error(L);
}

/** void pushPaletteAll(void)
 * inc/undo.h:25
 */
static int undo_pushPaletteAll(lua_State *L) {
	try {
		pushPaletteAll();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushPaletteAll: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushPaletteAll: Unknown exception");
	}

	return lua_error(L);
}

/** void pushChunk(unsigned int id, bool rm)
 * inc/undo.h:26
 */
static int undo_pushChunk(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		bool rm = dub::checkboolean(L, 2);
		pushChunk(id, rm);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushChunk: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushChunk: Unknown exception");
	}

	return lua_error(L);
}

/** void pushChunksAll(void)
 * inc/undo.h:27
 */
static int undo_pushChunksAll(lua_State *L) {
	try {
		pushChunksAll();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushChunksAll: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushChunksAll: Unknown exception");
	}

	return lua_error(L);
}

/** void pushChunkResize(unsigned int wnew, unsigned int hnew)
 * inc/undo.h:28
 */
static int undo_pushChunkResize(lua_State *L) {
	try {
		unsigned int wnew = dub::checkinteger(L, 1);
		unsigned int hnew = dub::checkinteger(L, 2);
		pushChunkResize(wnew, hnew);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushChunkResize: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushChunkResize: Unknown exception");
	}

	return lua_error(L);
}

/** void pushChunkEdit(unsigned int id, unsigned int x, unsigned int y)
 * inc/undo.h:29
 */
static int undo_pushChunkEdit(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		unsigned int x = dub::checkinteger(L, 2);
		unsigned int y = dub::checkinteger(L, 3);
		pushChunkEdit(id, x, y);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushChunkEdit: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushChunkEdit: Unknown exception");
	}

	return lua_error(L);
}

/** void pushChunkAppend(void)
 * inc/undo.h:30
 */
static int undo_pushChunkAppend(lua_State *L) {
	try {
		pushChunkAppend();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushChunkAppend: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushChunkAppend: Unknown exception");
	}

	return lua_error(L);
}

/** void pushChunkNew(unsigned int id)
 * inc/undo.h:31
 */
static int undo_pushChunkNew(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		pushChunkNew(id);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushChunkNew: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushChunkNew: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteAppend(unsigned int id)
 * inc/undo.h:32
 */
static int undo_pushSpriteAppend(lua_State *L) {
	try {
		unsigned int id = dub::checkinteger(L, 1);
		pushSpriteAppend(id);
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteAppend: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteAppend: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteAppendgroup(void)
 * inc/undo.h:33
 */
static int undo_pushSpriteAppendgroup(lua_State *L) {
	try {
		pushSpriteAppendgroup();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteAppendgroup: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteAppendgroup: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteWidth(void)
 * inc/undo.h:34
 */
static int undo_pushSpriteWidth(lua_State *L) {
	try {
		pushSpriteWidth();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteWidth: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteWidth: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteHeight(void)
 * inc/undo.h:35
 */
static int undo_pushSpriteHeight(lua_State *L) {
	try {
		pushSpriteHeight();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteHeight: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteHeight: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpritePalrow(void)
 * inc/undo.h:36
 */
static int undo_pushSpritePalrow(lua_State *L) {
	try {
		pushSpritePalrow();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpritePalrow: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpritePalrow: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteStarttile(void)
 * inc/undo.h:37
 */
static int undo_pushSpriteStarttile(lua_State *L) {
	try {
		pushSpriteStarttile();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteStarttile: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteStarttile: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteLoadat(void)
 * inc/undo.h:38
 */
static int undo_pushSpriteLoadat(lua_State *L) {
	try {
		pushSpriteLoadat();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteLoadat: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteLoadat: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteOffx(void)
 * inc/undo.h:39
 */
static int undo_pushSpriteOffx(lua_State *L) {
	try {
		pushSpriteOffx();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteOffx: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteOffx: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteOffy(void)
 * inc/undo.h:40
 */
static int undo_pushSpriteOffy(lua_State *L) {
	try {
		pushSpriteOffy();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteOffy: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteOffy: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteHflip(void)
 * inc/undo.h:41
 */
static int undo_pushSpriteHflip(lua_State *L) {
	try {
		pushSpriteHflip();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteHflip: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteHflip: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpriteVflip(void)
 * inc/undo.h:42
 */
static int undo_pushSpriteVflip(lua_State *L) {
	try {
		pushSpriteVflip();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpriteVflip: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpriteVflip: Unknown exception");
	}

	return lua_error(L);
}

/** void pushSpritePrio(void)
 * inc/undo.h:43
 */
static int undo_pushSpritePrio(lua_State *L) {
	try {
		pushSpritePrio();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushSpritePrio: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushSpritePrio: Unknown exception");
	}

	return lua_error(L);
}

/** void pushProject(void)
 * inc/undo.h:44
 */
static int undo_pushProject(lua_State *L) {
	try {
		pushProject();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushProject: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushProject: Unknown exception");
	}

	return lua_error(L);
}

/** void pushProjectAppend(void)
 * inc/undo.h:45
 */
static int undo_pushProjectAppend(lua_State *L) {
	try {
		pushProjectAppend();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushProjectAppend: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushProjectAppend: Unknown exception");
	}

	return lua_error(L);
}

/** void pushProjectAll(void)
 * inc/undo.h:46
 */
static int undo_pushProjectAll(lua_State *L) {
	try {
		pushProjectAll();
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "undo.pushProjectAll: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "undo.pushProjectAll: Unknown exception");
	}

	return lua_error(L);
}

// --=============================================== FUNCTIONS
static const struct luaL_Reg undo_functions[] = {
	{ "pushTile", undo_pushTile        },
	{ "pushTilenew", undo_pushTilenew     },
	{ "pushTilePixel", undo_pushTilePixel   },
	{ "pushTileGroupPrepare", undo_pushTileGroupPrepare },
	{ "addTileGroup", undo_addTileGroup    },
	{ "pushTileappendGroupPrepare", undo_pushTileappendGroupPrepare },
	{ "pushTilesAll", undo_pushTilesAll    },
	{ "pushTileAppend", undo_pushTileAppend  },
	{ "pushTilemapEdit", undo_pushTilemapEdit },
	{ "pushTilemapResize", undo_pushTilemapResize },
	{ "pushTilemapBlocksAmt", undo_pushTilemapBlocksAmt },
	{ "pushTilemapAll", undo_pushTilemapAll  },
	{ "pushTilemapPlaneDelete", undo_pushTilemapPlaneDelete },
	{ "pushTilemapPlaneAdd", undo_pushTilemapPlaneAdd },
	{ "pushExtAttrs", undo_pushExtAttrs    },
	{ "pushPaletteEntry", undo_pushPaletteEntry },
	{ "pushPaletteAll", undo_pushPaletteAll  },
	{ "pushChunk", undo_pushChunk       },
	{ "pushChunksAll", undo_pushChunksAll   },
	{ "pushChunkResize", undo_pushChunkResize },
	{ "pushChunkEdit", undo_pushChunkEdit   },
	{ "pushChunkAppend", undo_pushChunkAppend },
	{ "pushChunkNew", undo_pushChunkNew    },
	{ "pushSpriteAppend", undo_pushSpriteAppend },
	{ "pushSpriteAppendgroup", undo_pushSpriteAppendgroup },
	{ "pushSpriteWidth", undo_pushSpriteWidth },
	{ "pushSpriteHeight", undo_pushSpriteHeight },
	{ "pushSpritePalrow", undo_pushSpritePalrow },
	{ "pushSpriteStarttile", undo_pushSpriteStarttile },
	{ "pushSpriteLoadat", undo_pushSpriteLoadat },
	{ "pushSpriteOffx", undo_pushSpriteOffx  },
	{ "pushSpriteOffy", undo_pushSpriteOffy  },
	{ "pushSpriteHflip", undo_pushSpriteHflip },
	{ "pushSpriteVflip", undo_pushSpriteVflip },
	{ "pushSpritePrio", undo_pushSpritePrio  },
	{ "pushProject", undo_pushProject     },
	{ "pushProjectAppend", undo_pushProjectAppend },
	{ "pushProjectAll", undo_pushProjectAll  },
	{ NULL, NULL},
};

// --=============================================== CONSTANTS
static const struct dub::const_Reg undo_const[] = {
	{ "tTypeTile", ::tTypeTile          },
	{ "tTypeTruecolor", ::tTypeTruecolor     },
	{ "tTypeBoth", ::tTypeBoth          },
	{ "tTypeDeleteFlag", ::tTypeDeleteFlag    },
	{ "tTypeDelete", ::tTypeDelete        },
	{ NULL, 0},
};

int luaopen_undoLua(lua_State *L) {
	lua_newtable(L);
	// <lib>
	// register global constants
	dub::register_const(L, undo_const);
	dub::fregister(L, undo_functions);
	// <lib>


	// <lib>
	return 1;
}
