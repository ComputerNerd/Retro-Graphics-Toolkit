/**
 *
 * MACHINE GENERATED FILE. DO NOT EDIT.
 *
 * Bindings for class filereader
 *
 * This file has been generated by dub 2.2.4.
 */
#include "dub/dub.h"
#include "filereader.h"


/** Set attributes (key, value)
 *
 */
static int filereader__set_(lua_State *L) {

	filereader *self = *((filereader **)dub::checksdata_n(L, 1, "filereader.filereader"));
	const char *key = luaL_checkstring(L, 2);

	if (lua_istable(L, 1))
		lua_rawset(L, 1);

	else
		luaL_error(L, KEY_EXCEPTION_MSG, key);

	return 0;
}

/** Get attributes (key)
 *
 */
static int filereader__get_(lua_State *L) {

	filereader *self = *((filereader **)dub::checksdata_n(L, 1, "filereader.filereader", true));
	const char *key = luaL_checkstring(L, 2);
	// <self> "key" <mt>
	// rawget(mt, key)
	lua_pushvalue(L, 2);
	// <self> "key" <mt> "key"
	lua_rawget(L, -2);

	if (!lua_isnil(L, -1)) {
		// Found method.
		return 1;
	} else {
		// Not in mt = attribute access.
		lua_pop(L, 2);
	}

	int key_h = dub::hash(key, 2);

	switch (key_h) {
		case 0: {
			if (DUB_ASSERT_KEY(key, "amt")) break;

			lua_pushinteger(L, self->amt);
			return 1;
		}

		case 1: {
			if (DUB_ASSERT_KEY(key, "lenTotal")) break;

			lua_pushinteger(L, self->lenTotal);
			return 1;
		}
	}

	return 0;
}

/** Read lens(size_t i)
 *
 */
static int filereader_lens(lua_State *L) {
	try {
		filereader *self = *((filereader **)dub::checksdata(L, 1, "filereader.filereader"));
		int top__ = lua_gettop(L);

		if (top__ >= 3)
			return 0;

		else {
			size_t i = dub::checkinteger(L, 2);

			if (!i || i > self->lens.size()) return 0;

			lua_pushnumber(L, self->lens[i - 1]);
			return 1;
		}
	} catch (std::exception &e) {
		lua_pushfstring(L, "lens: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "lens: Unknown exception");
	}

	return dub::error(L);
}

/** Read dat(size_t i)
 *
 */
static int filereader_dat(lua_State *L) {
	try {
		filereader *self = *((filereader **)dub::checksdata(L, 1, "filereader.filereader"));
		int top__ = lua_gettop(L);

		if (top__ >= 3)
			return 0;

		else {
			size_t i = dub::checkinteger(L, 2);

			if (!i || i > self->dat.size()) return 0;

			const void *retval__ = self->dat[i - 1];

			if (!retval__) return 0;

			lua_pushlstring(L, (const char*)retval__, self->lens[i - 1]);
			return 1;
		}
	} catch (std::exception &e) {
		lua_pushfstring(L, "dat: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "dat: Unknown exception");
	}

	return dub::error(L);
}

/** Read names(size_t i)
 *
 */
static int filereader_names(lua_State *L) {
	try {
		filereader *self = *((filereader **)dub::checksdata(L, 1, "filereader.filereader"));
		int top__ = lua_gettop(L);

		if (top__ >= 3) {
			size_t i = dub::checkinteger(L, 2);
			size_t v_sz_;
			const char *v = dub::checklstring(L, 3, &v_sz_);

			if (!i || i > self->names.size()) return 0;

			self->names[i - 1] = std::string(v, v_sz_);
			return 0;
		} else {
			size_t i = dub::checkinteger(L, 2);

			if (!i || i > self->names.size()) return 0;

			lua_pushlstring(L, self->names[i - 1].data(), self->names[i - 1].length());
			return 1;
		}
	} catch (std::exception &e) {
		lua_pushfstring(L, "names: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "names: Unknown exception");
	}

	return dub::error(L);
}

/** filereader::filereader(int endian, unsigned bytesPerElement, const char *title=nullptr, bool relptr=false, unsigned offbits=16, bool be=true, const char *filename=nullptr, fileType_t forceType=fileType_t::tCancel, CompressionType compression=CompressionType::Cancel)
 * incFileReader/filereader.h:29
 */
static int filereader_filereader(lua_State *L) {
	try {
		int top__ = lua_gettop(L);

		boost::endian::order endian = (boost::endian::order)dub::checkinteger(L, 1);
		unsigned bytesPerElement = dub::checkinteger(L, 2);
		filereader *retval__;

		if (top__ >= 9) {
			const char *title = dub::checkstring(L, 3);
			bool relptr = dub::checkboolean(L, 4);
			unsigned offbits = dub::checkinteger(L, 5);
			bool be = dub::checkboolean(L, 6);
			const char *filename = dub::checkstring(L, 7);
			fileType_t forceType = (fileType_t)dub::checkinteger(L, 8);
			CompressionType compression = (CompressionType)dub::checkinteger(L, 9);
			retval__ = new filereader(endian, bytesPerElement, title, relptr, offbits, be, filename, forceType, compression);
		} else if (top__ >= 8) {
			const char *title = dub::checkstring(L, 3);
			bool relptr = dub::checkboolean(L, 4);
			unsigned offbits = dub::checkinteger(L, 5);
			bool be = dub::checkboolean(L, 6);
			const char *filename = dub::checkstring(L, 7);
			fileType_t forceType = (fileType_t)dub::checkinteger(L, 8);
			retval__ = new filereader(endian, bytesPerElement, title, relptr, offbits, be, filename, forceType);
		} else if (top__ >= 7) {
			const char *title = dub::checkstring(L, 3);
			bool relptr = dub::checkboolean(L, 4);
			unsigned offbits = dub::checkinteger(L, 5);
			bool be = dub::checkboolean(L, 6);
			const char *filename = dub::checkstring(L, 7);
			retval__ = new filereader(endian, bytesPerElement, title, relptr, offbits, be, filename);
		} else if (top__ >= 6) {
			const char *title = dub::checkstring(L, 3);
			bool relptr = dub::checkboolean(L, 4);
			unsigned offbits = dub::checkinteger(L, 5);
			bool be = dub::checkboolean(L, 6);
			retval__ = new filereader(endian, bytesPerElement, title, relptr, offbits, be);
		} else if (top__ >= 5) {
			const char *title = dub::checkstring(L, 3);
			bool relptr = dub::checkboolean(L, 4);
			unsigned offbits = dub::checkinteger(L, 5);
			retval__ = new filereader(endian, bytesPerElement, title, relptr, offbits);
		} else if (top__ >= 4) {
			const char *title = dub::checkstring(L, 3);
			bool relptr = dub::checkboolean(L, 4);
			retval__ = new filereader(endian, bytesPerElement, title, relptr);
		} else if (top__ >= 3) {
			const char *title = dub::checkstring(L, 3);
			retval__ = new filereader(endian, bytesPerElement, title);
		} else if (top__ >= 2)
			retval__ = new filereader(endian, bytesPerElement);

		else
			return 0;

		dub::pushudata(L, retval__, "filereader.filereader", true);
		return 1;
	} catch (std::exception &e) {
		lua_pushfstring(L, "new: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "new: Unknown exception");
	}

	return dub::error(L);
}

/** unsigned filereader::selDat(void)
 * incFileReader/filereader.h:30
 */
static int filereader_selDat(lua_State *L) {
	try {
		filereader *self = *((filereader **)dub::checksdata(L, 1, "filereader.filereader"));
		lua_pushnumber(L, self->selDat());
		return 1;
	} catch (std::exception &e) {
		lua_pushfstring(L, "selDat: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "selDat: Unknown exception");
	}

	return dub::error(L);
}

/** filereader::~filereader()
 * incFileReader/filereader.h:31
 */
static int filereader__filereader(lua_State *L) {
	try {
		DubUserdata *userdata = ((DubUserdata*)dub::checksdata_d(L, 1, "filereader.filereader"));

		if (userdata->gc) {
			filereader *self = (filereader *)userdata->ptr;
			delete self;
		}

		userdata->gc = false;
		return 0;
	} catch (std::exception &e) {
		lua_pushfstring(L, "__gc: %s", e.what());
	} catch (...) {
		lua_pushfstring(L, "__gc: Unknown exception");
	}

	return dub::error(L);
}



// --=============================================== __tostring
static int filereader___tostring(lua_State *L) {
	filereader *self = *((filereader **)dub::checksdata_n(L, 1, "filereader.filereader"));
	lua_pushfstring(L, "filereader.filereader: %p", self);

	return 1;
}

// --=============================================== METHODS

static const struct luaL_Reg filereader_member_methods[] = {
	{ "__newindex", filereader__set_     },
	{ "__index", filereader__get_     },
	{ "lens", filereader_lens      },
	{ "dat", filereader_dat       },
	{ "names", filereader_names     },
	{ "new", filereader_filereader },
	{ "selDat", filereader_selDat    },
	{ "__gc", filereader__filereader },
	{ "__tostring", filereader___tostring },
	{ "deleted", dub::isDeleted       },
	{ NULL, NULL},
};


int luaopen_filereader_filereader(lua_State *L)
{
	// Create the metatable which will contain all the member methods
	luaL_newmetatable(L, "filereader.filereader");
	// <mt>

	// register member methods
	dub::fregister(L, filereader_member_methods);
	// setup meta-table
	dub::setup(L, "filereader.filereader");
	// <mt>
	return 1;
}
